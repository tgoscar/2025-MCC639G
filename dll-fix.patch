diff --git a/doublelinkedlist.h b/doublelinkedlist.h
index 0000000..1111111 100644
--- a/doublelinkedlist.h
+++ b/doublelinkedlist.h
@@ -1,999 +1,260 @@
-/* contenido previo */
+// Implementación segura de Lista Doblemente Enlazada
+#ifndef DOUBLE_LINKED_LIST_H
+#define DOUBLE_LINKED_LIST_H
+
+#include <cstddef>
+#include <initializer_list>
+#include <iterator>
+#include <stdexcept>
+#include <utility>
+
+template <typename T>
+class DoublyLinkedList {
+private:
+    struct Node {
+        T value;
+        Node* prev;
+        Node* next;
+        explicit Node(const T& v, Node* p=nullptr, Node* n=nullptr)
+            : value(v), prev(p), next(n) {}
+        explicit Node(T&& v, Node* p=nullptr, Node* n=nullptr)
+            : value(std::move(v)), prev(p), next(n) {}
+    };
+
+    Node* head_{nullptr};
+    Node* tail_{nullptr};
+    std::size_t size_{0};
+
+    void link_between(Node* left, Node* right, Node* mid) noexcept {
+        mid->prev = left;
+        mid->next = right;
+        if (left) left->next = mid; else head_ = mid;
+        if (right) right->prev = mid; else tail_ = mid;
+        ++size_;
+    }
+    void unlink(Node* n) noexcept {
+        Node* L = n->prev;
+        Node* R = n->next;
+        if (L) L->next = R; else head_ = R;
+        if (R) R->prev = L; else tail_ = L;
+        --size_;
+    }
+    void copy_from(const DoublyLinkedList& other) {
+        for (const auto& v : other) push_back(v);
+    }
+
+public:
+    template <bool IsConst>
+    class basic_iterator {
+        using NodePtr = typename std::conditional<IsConst, const Node*, Node*>::type;
+        NodePtr node_{nullptr};
+    public:
+        using iterator_category = std::bidirectional_iterator_tag;
+        using value_type        = T;
+        using difference_type   = std::ptrdiff_t;
+        using pointer           = typename std::conditional<IsConst, const T*, T*>::type;
+        using reference         = typename std::conditional<IsConst, const T&, T&>::type;
+
+        basic_iterator() = default;
+        explicit basic_iterator(NodePtr n) : node_(n) {}
+        reference operator*()  const { return const_cast<reference>(node_->value); }
+        pointer   operator->() const { return &const_cast<reference>(node_->value); }
+        basic_iterator& operator++() { node_ = node_ ? node_->next : nullptr; return *this; }
+        basic_iterator  operator++(int){ auto t=*this; ++(*this); return t; }
+        basic_iterator& operator--() { node_ = node_ ? node_->prev : node_; return *this; }
+        basic_iterator  operator--(int){ auto t=*this; --(*this); return t; }
+        friend bool operator==(const basic_iterator& a, const basic_iterator& b){ return a.node_==b.node_; }
+        friend bool operator!=(const basic_iterator& a, const basic_iterator& b){ return !(a==b); }
+        template<typename> friend class DoublyLinkedList;
+    };
+    using iterator = basic_iterator<false>;
+    using const_iterator = basic_iterator<true>;
+
+    DoublyLinkedList() = default;
+    DoublyLinkedList(std::initializer_list<T> il) { for (auto& v: il) push_back(v); }
+    DoublyLinkedList(const DoublyLinkedList& other) { copy_from(other); }
+    DoublyLinkedList(DoublyLinkedList&& other) noexcept
+        : head_(other.head_), tail_(other.tail_), size_(other.size_) {
+        other.head_ = other.tail_ = nullptr; other.size_ = 0;
+    }
+    DoublyLinkedList& operator=(DoublyLinkedList other) noexcept { swap(other); return *this; }
+    ~DoublyLinkedList() { clear(); }
+
+    // capacidad
+    std::size_t size()  const noexcept { return size_; }
+    bool        empty() const noexcept { return size_ == 0; }
+
+    // iteradores
+    iterator begin() noexcept { return iterator(head_); }
+    iterator end()   noexcept { return iterator(nullptr); }
+    const_iterator begin() const noexcept { return const_iterator(head_); }
+    const_iterator end()   const noexcept { return const_iterator(nullptr); }
+    const_iterator cbegin() const noexcept { return const_iterator(head_); }
+    const_iterator cend()   const noexcept { return const_iterator(nullptr); }
+
+    // acceso
+    T& front() {
+        if (!head_) throw std::out_of_range("front() en lista vacía");
+        return head_->value;
+    }
+    const T& front() const {
+        if (!head_) throw std::out_of_range("front() en lista vacía");
+        return head_->value;
+    }
+    T& back() {
+        if (!tail_) throw std::out_of_range("back() en lista vacía");
+        return tail_->value;
+    }
+    const T& back() const {
+        if (!tail_) throw std::out_of_range("back() en lista vacía");
+        return tail_->value;
+    }
+
+    // modificación
+    void clear() noexcept {
+        Node* cur = head_;
+        while (cur) {
+            Node* nxt = cur->next;
+            delete cur;
+            cur = nxt;
+        }
+        head_ = tail_ = nullptr;
+        size_ = 0;
+    }
+    void push_front(const T& v)    { link_between(nullptr, head_, new Node(v)); }
+    void push_front(T&& v)         { link_between(nullptr, head_, new Node(std::move(v))); }
+    void push_back(const T& v)     { link_between(tail_, nullptr, new Node(v)); }
+    void push_back(T&& v)          { link_between(tail_, nullptr, new Node(std::move(v))); }
+    void pop_front() {
+        if (!head_) throw std::out_of_range("pop_front() en lista vacía");
+        Node* n = head_; unlink(n); delete n;
+    }
+    void pop_back() {
+        if (!tail_) throw std::out_of_range("pop_back() en lista vacía");
+        Node* n = tail_; unlink(n); delete n;
+    }
+    // inserta antes de pos; si pos==end(), inserta al final
+    iterator insert(iterator pos, const T& v) {
+        if (pos.node_ == nullptr) { link_between(tail_, nullptr, new Node(v)); return iterator(tail_); }
+        Node* right = const_cast<Node*>(pos.node_);
+        link_between(right->prev, right, new Node(v));
+        return iterator(right->prev);
+    }
+    iterator insert(iterator pos, T&& v) {
+        if (pos.node_ == nullptr) { link_between(tail_, nullptr, new Node(std::move(v))); return iterator(tail_); }
+        Node* right = const_cast<Node*>(pos.node_);
+        link_between(right->prev, right, new Node(std::move(v)));
+        return iterator(right->prev);
+    }
+    iterator erase(iterator pos) {
+        if (pos.node_ == nullptr) throw std::out_of_range("erase(end())");
+        Node* n = const_cast<Node*>(pos.node_);
+        iterator ret(n->next);
+        unlink(n); delete n;
+        return ret;
+    }
+    void swap(DoublyLinkedList& other) noexcept {
+        std::swap(head_, other.head_);
+        std::swap(tail_, other.tail_);
+        std::swap(size_, other.size_);
+    }
+};
+
+#endif // DOUBLE_LINKED_LIST_H
diff --git a/main.cpp b/main.cpp
index 0000000..2222222 100644
--- a/main.cpp
+++ b/main.cpp
@@ -1,200 +1,40 @@
-/* contenido previo */
+// Demo mínima para validar la lista doblemente enlazada
+#include <iostream>
+#include "doublelinkedlist.h"
+int main(){
+    DoublyLinkedList<int> L;
+    L.push_back(1);
+    L.push_front(0);
+    L.push_back(2);
+    std::cout << "size=" << L.size() << " front=" << L.front() << " back=" << L.back() << "\n";
+
+    // insertar antes de begin y en end
+    auto it = L.begin();
+    L.insert(it, -1);
+    L.insert(L.end(), 3);
+
+    // borrar el 2
+    for (auto i=L.begin(); i!=L.end(); ){
+        if (*i==2) i = L.erase(i);
+        else ++i;
+    }
+
+    std::cout << "Contenido: ";
+    for (const auto& v: L) std::cout << v << ' ';
+    std::cout << "\nOK\n";
+    return 0;
+}
diff --git a/test.cpp b/test.cpp
index 0000000..3333333 100644
--- a/test.cpp
+++ b/test.cpp
@@ -1,200 +1,40 @@
-/* contenido previo */
+#include <cassert>
+#include "doublelinkedlist.h"
+int main(){
+    DoublyLinkedList<int> L;
+    assert(L.empty());
+    L.push_back(10); L.push_front(5); L.push_back(20);
+    assert(L.size()==3 && L.front()==5 && L.back()==20);
+
+    auto it = L.begin(); ++it; // apunta a 10
+    L.insert(it, 8);           // 5,8,10,20
+    assert(L.size()==4);
+
+    // borra 10
+    for (auto i=L.begin(); i!=L.end();){
+        if (*i==10) i = L.erase(i); else ++i;
+    }
+    assert(L.size()==3);
+
+    // limpiar
+    L.clear();
+    assert(L.empty());
+    return 0;
+}
diff --git a/Makefile b/Makefile
index 0000000..4444444 100644
--- a/Makefile
+++ b/Makefile
@@ -1,50 +1,50 @@
-# contenido previo
+ CXX      ?= g++
+ CXXFLAGS ?= -std=c++17 -O2 -Wall -Wextra -pedantic
+
+ all: app
+
+ app: main.cpp doublelinkedlist.h
+	$(CXX) $(CXXFLAGS) main.cpp -o app
+
+.PHONY: test
+ test: test.cpp doublelinkedlist.h
+	$(CXX) $(CXXFLAGS) test.cpp -o tests && ./tests
